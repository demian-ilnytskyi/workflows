# release_build.yaml
name: Next JS Build

# Controls when the workflow will run
on:
  workflow_call:
    inputs:
      FLAVOUR:
        required: true
        type: string
        default: "production"
      runs_on:
        required: false
        type: string
        default: "ubuntu-latest"
      folder_max_mb_size:
        required: false
        type: number
        default: 3
      secrets_map:
        required: false
        type: string
        default: ""

permissions:
  id-token: write # This is required for requesting the JWT
  contents: read # This is required for actions/checkout

jobs:
  build:
    runs-on: ${{inputs.runs_on}} # We are using ubuntu to deploy flutter web
    timeout-minutes: 20
    environment: ${{inputs.FLAVOUR}}
    steps:
      - name: Checkout
        uses: actions/checkout@main
      - name: Set Up Node.js
        uses: actions/setup-node@main
        with:
          node-version: ${{ vars.NODE_FRAMEWORK_VERSION }}
      - name: ðŸ“¦ Install Dependencies
       # npm ci instead of npm install to not overwrite package_lock.json
        run: npm install

      - name: Set env
        id: prepare_env # An ID is required to reference its output
        env:
          SECRETS_CONTEXT: ${{ toJSON(secrets) }}
        run: |
          # Use command substitution to capture the output of the loop into a variable
          SECRET_DEFINITIONS=$(
            echo "${{ inputs.secrets_map }}" | while IFS=':' read -r env_var secret_name; do
              env_var=$(echo "$env_var" | xargs)
              secret_name=$(echo "$secret_name" | xargs)

              if [[ -n "$secret_name" && -n "$env_var" ]]; then
                secret_value=$(echo "$SECRETS_CONTEXT" | jq -r --arg key "$secret_name" '.[$key]')

                if [[ "$secret_value" != "null" && -n "$secret_value" ]]; then
                  # If it's a NEXT_PUBLIC_ variable â†’ add to GITHUB_ENV for the build
                  if [[ "$env_var" == NEXT_PUBLIC_* ]]; then
                    echo "$env_var=$secret_value" >> "$GITHUB_ENV"
                    echo "âœ… Added public var for build: $env_var"
                  else
                    # Otherwise, print the definition to be captured by the variable
                    printf '%s="%s"\n' "$env_var" "$secret_value"
                  fi
                fi
              fi
            done
          )

          echo "NEXT_PUBLIC_FLAVOUR=${{ inputs.FLAVOUR }}" >> $GITHUB_ENV
          
          echo "secret_definitions<<EOF" >> "$GITHUB_OUTPUT"
          echo "$SECRET_DEFINITIONS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Set Build Number
        run: |
          BUILD_NUMBER=$(date +%s)

          mkdir -p public
          echo "{\"BUILD_ID\": \"$BUILD_NUMBER\"}" > "public/config.json"
        shell: bash
          
      - name: Deploy
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{secrets.CLOUDFLARE_API_TOKEN}}
          accountId: ${{secrets.CLOUDFLARE_ACCOUNT_ID}}
          command: deploy
          packageManager: npm
          environment: ${{ inputs.FLAVOUR != 'production' && inputs.FLAVOUR || '' }}
          preCommands: |
            # Read the list of secrets from the previous step's output and set them
            echo "ðŸ”’ Setting secrets in Cloudflare..."
            echo "${{ steps.prepare_env.outputs.secret_definitions }}" | while IFS= read -r line; do
              if [[ -n "$line" ]]; then
                # Extract the variable name (the part before the first '=')
                SECRET_KEY=$(echo "$line" | cut -d'=' -f1)
                
                # Evaluate the line to set the variable in the shell, then pipe its value to wrangler
                # This safely handles multi-line secrets
                eval "SECRET_VALUE=${line#*=}"
                echo "$SECRET_VALUE" | npx wrangler secret put "$SECRET_KEY"
              fi
            done
            echo "âœ… Secrets set."

            npm run pre-deploy
            chmod +x ./check_app_size.sh
            ./check_app_size.sh
  notify:
    if: always() # Ensures this job runs regardless of the completion status of dependent jobs
    needs:
      - build
    uses: ./.github/workflows/notification.yml
    secrets: inherit
    with:
      job_status: ${{ needs.build.result }}
      workflow: ${{ github.workflow }}
      runs_on: ${{inputs.runs_on}}